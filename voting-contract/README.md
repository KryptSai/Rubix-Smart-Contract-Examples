This folder demonstrates a simple DAPP which can generate,subscribe,deploy and execute a simple voting contract to Rubix Network. 
The contract is simple, any node which is subscribing to the contract can vote for a colour, either blue or red. When each node vote for a colour, the statefile in all the nodes subscribed to the contract gets updated.

The flow of execution for this program :
1. The state updation logic is written in Rust and is compiled to wasm using `cargo build --target wasm32-unknown-unknown`. [The first "unknown" refers to the target's operating system, and the second "unknown" refers to the target environment. Both of these are given as unknown so that the execution of the wasm can take place in any systems.]
2. Once the wasm file is ready, we have to generate the smart contract in Rubix and deploy it. For generating a smart contract we have an api :**/api/generate-smart-contract**[There are some input parameters which needs to be given. Please check the **swagger** of your Rubix node to learn more about that ]. Once this api is called, it will be returned with a smart contract token hash. All the next steps which we are going to perform will revolve around this smart contract hash.
3. The next step here is to subscribe to the smart contract. The nodes which are interested to be part of the voting-contract subscribe to the smart contract using the smart contract hash which was generated during the generation of smart contract. Along with subscribing the smart contract, a call back url which is an endpoint in the dapp should be registered wiyth the subscribing node. So that each time the smart contract token chain is updated the node can trigger this endpoint in the dapp so that the stae updation logic which is there in the wasm can be triggered. 
4. Once the subscription is done, we can deploy the smart contract to the network. For deploying the smart contract we have an api : **/api/deploy-smart-contract**[There are some input parameters which needs to be given. Please check the **swagger** of your Rubix node to learn more about that ]. The deploy smart contract should be done by the node which has generated the smart contract. 
5. Once the smart contract is deployed, the nodes which are subscribed to the smart contract can execute the contract. For executing the contract we have an api : **/api/execute-smart-contract**[There are some input parameters which needs to be given. Please check the **swagger** of your Rubix node to learn more about that ]. The  api should be called by the nodes which are subscribed to the smart contract.Here in the case of the voting, contract executing the contract means adding the **Vote** either red or blue to the smart contract token chain which was created while generating the contract. Each time a node executes the contract the particular input which is given by the node is recorded in the smart contract token chain.
6. As I said in the above point when contract is executed the token chain is updated, so the tokenchain present in each of the node which have been subscribed to the smart contract will get updated. When the token chain gets updated the Rubix node triggers the api endpoint which was registered before and will perform the state updation using the wasm file.